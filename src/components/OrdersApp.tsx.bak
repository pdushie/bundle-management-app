import React, { useState, useEffect } from "react";
import { Download, Clock, FileText, User, Database, CheckCircle, XCircle, Loader, Search, SlidersHorizontal, Check, CheckSquare, Square, Archive } from "lucide-react";
import ExcelJS from "exceljs";
import JSZip from "jszip";
import { getPendingOrdersOldestFirst, getOrdersOldestFirst, saveOrders, updateOrder } from "../lib/orderClient";
import { useOrderCount } from "../lib/orderContext";
import { ORDER_UPDATED_EVENT } from "../lib/orderNotifications";

  // Define the Order type to represent an order in the queue
type OrderEntryStatus = "pending" | "sent" | "error";

type Order = {
  id: string;
  timestamp: number;
  date: string;
  time: string;
  userName: string;
  userEmail: string;
  totalData: number;
  totalCount: number;
  status: "pending" | "processed";
  entries: Array<{
    number: string;
    allocationGB: number;
    status?: OrderEntryStatus;
  }>;
  isSelected?: boolean;
};export default function OrdersApp() {
  const [orders, setOrders] = useState<Order[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [searchTerm, setSearchTerm] = useState<string>("");
  const [statusFilter, setStatusFilter] = useState<"all" | "pending" | "processed">("all");
  const [sortField, setSortField] = useState<"date" | "userName" | "totalData" | "totalCount">("date");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc"); // Changed to "asc" so oldest orders appear at the top
  const [selectAll, setSelectAll] = useState<boolean>(false);
  const [selectedOrderIds, setSelectedOrderIds] = useState<string[]>([]);
  const [currentPage, setCurrentPage] = useState<number>(1);
  const [itemsPerPage] = useState<number>(25);
  
  // Get the refreshOrderCount function from context
  const { refreshOrderCount } = useOrderCount();

  // Load orders from database or generate mock data if none exist
  useEffect(() => {
    let isMounted = true;
    
    const loadOrders = async () => {
      if (!isMounted) return;
      
      try {
        setIsLoading(true);
        // Try to load ALL orders from database first, not just pending ones
        const allOrders = await getOrdersOldestFirst();
        
        if (!isMounted) return;
        
        if (allOrders.length > 0) {
          // If we have orders in database, use those
          setOrders(allOrders);
        } else {
          // Otherwise generate mock data
          const mockOrders: Order[] = Array.from({ length: 10 }, (_, i) => {
            const date = new Date();
            date.setDate(date.getDate() - i); // Each order is a day apart
            
            const status: Order["status"][] = ["pending", "processed"];
            const randomStatus = status[Math.floor(Math.random() * status.length)];
            
            const phoneCount = Math.floor(Math.random() * 45) + 5; // Between 5 and 50
            const totalGB = Number((Math.random() * 100 + 10).toFixed(2)); // Between 10 and 110 GB
            
            // Generate mock entries
            const entries = Array.from({ length: phoneCount }, (_, j) => {
              const entryStatus: OrderEntryStatus = 
                randomStatus === "processed" ? "sent" : "pending";
                
              return {
                number: `0${Math.floor(Math.random() * 900000000) + 100000000}`, // Random 10-digit number starting with 0
                allocationGB: Number((totalGB / phoneCount).toFixed(2)),
                status: entryStatus
              };
            });
            
            return {
              id: `order-${Date.now()}-${i}`,
              timestamp: date.getTime(),
              date: date.toISOString().split('T')[0],
              time: date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
              userName: ["John Doe", "Jane Smith", "Alex Johnson", "Sam Wilson", "Maria Garcia"][i % 5],
              userEmail: ["john@example.com", "jane@example.com", "alex@example.com", "sam@example.com", "maria@example.com"][i % 5],
              totalData: totalGB,
              totalCount: phoneCount,
              status: randomStatus,
              entries,
              isSelected: false
            };
          });
          
          // Save mock data to database for persistence
          setOrders(mockOrders);
          if (isMounted) {
            await saveOrders(mockOrders);
          }
        }
        
        // Refresh the order count in the context only once after loading orders
        // Not in the dependency array to avoid infinite loops
        if (isMounted) {
          refreshOrderCount();
        }
      } catch (error) {
        console.error("Error loading orders:", error);
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    };
    
    loadOrders();
    
    // Cleanup function
    return () => {
      isMounted = false;
    };
  }, []); // Empty dependency array to run only once

  // Handle toggle select all
  const handleToggleSelectAll = () => {
    const newSelectAll = !selectAll;
    setSelectAll(newSelectAll);
    
    // Update all filtered orders
    const updatedOrders = orders.map(order => {
      // Only update orders that are in the current filtered view
      if (isOrderInFilteredView(order)) {
        return { ...order, isSelected: newSelectAll };
      }
      return order;
    });
    
    setOrders(updatedOrders);
    
    // Update selected IDs
    if (newSelectAll) {
      setSelectedOrderIds(filteredOrders.map(order => order.id));
    } else {
      setSelectedOrderIds([]);
    }
  };
  
  // Check if an order should be in the current filtered view
  const isOrderInFilteredView = (order: Order): boolean => {
    // Status filtering is now handled separately before calling this function
    
    // Apply search filter
    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase();
      return (
        order.userName.toLowerCase().includes(searchLower) ||
        order.userEmail.toLowerCase().includes(searchLower) ||
        order.date.includes(searchLower) ||
        order.id.toLowerCase().includes(searchLower)
      );
    }
    
    return true;
  };
  
  // Toggle selection for a single order
  const toggleOrderSelection = (orderId: string) => {
    const updatedOrders = orders.map(order => {
      if (order.id === orderId) {
        return { ...order, isSelected: !order.isSelected };
      }
      return order;
    });
    
    setOrders(updatedOrders);
    
    // Update the selected IDs list
    const orderToToggle = orders.find(o => o.id === orderId);
    if (orderToToggle) {
      if (orderToToggle.isSelected) {
        // It was previously selected, so we're removing it
        setSelectedOrderIds(prev => prev.filter(id => id !== orderId));
      } else {
        // It was previously unselected, so we're adding it
        setSelectedOrderIds(prev => [...prev, orderId]);
      }
    }
    
    // Update selectAll state
    const newSelectedCount = updatedOrders.filter(o => o.isSelected).length;
    const filteredCount = filteredOrders.length;
    setSelectAll(newSelectedCount > 0 && newSelectedCount === filteredCount);
  };
  
  // Filter out processed orders for the orders queue (only show pending ones), 
  // then apply any other filters and sort
  // Apply filters and sorting to all orders
  const allFilteredOrders = orders
    .filter(order => statusFilter === "all" ? order.status === "pending" : order.status === statusFilter)
    .filter(isOrderInFilteredView)
    .sort((a, b) => {
      // Apply sorting
      if (sortField === "date") {
        // Default sort is now oldest first (ascending by timestamp)
        return sortDirection === "asc" 
          ? a.timestamp - b.timestamp  // Oldest first
          : b.timestamp - a.timestamp; // Newest first
      }
      else if (sortField === "userName") {
        return sortDirection === "asc"
          ? a.userName.localeCompare(b.userName)
          : b.userName.localeCompare(a.userName);
      }
      else if (sortField === "totalData") {
        return sortDirection === "asc"
          ? a.totalData - b.totalData
          : b.totalData - a.totalData;
      }
      else if (sortField === "totalCount") {
        return sortDirection === "asc"
          ? a.totalCount - b.totalCount
          : b.totalCount - a.totalCount;
      }
      return 0;
    });
    
  // Calculate pagination indexes
  const indexOfLastItem = currentPage * itemsPerPage;
  const indexOfFirstItem = indexOfLastItem - itemsPerPage;
  
  // Get current page items
  const currentItems = allFilteredOrders.slice(indexOfFirstItem, indexOfLastItem);
      else if (sortField === "userName") {
        return sortDirection === "asc"
          ? a.userName.localeCompare(b.userName)
          : b.userName.localeCompare(a.userName);
      }
      else if (sortField === "totalData") {
        return sortDirection === "asc"
          ? a.totalData - b.totalData
          : b.totalData - a.totalData;
      }
      else if (sortField === "totalCount") {
        return sortDirection === "asc"
          ? a.totalCount - b.totalCount
          : b.totalCount - a.totalCount;
      }
      
      return 0;
    });

  // Toggle sort direction when clicking the same field
  const handleSort = (field: typeof sortField) => {
    if (field === sortField) {
      setSortDirection(sortDirection === "asc" ? "desc" : "asc");
    } else {
      setSortField(field);
      setSortDirection("desc");
    }
  };

  // Download order as Excel file
  const downloadOrder = async (order: Order) => {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet("PhoneData");
    
    // Add required header columns exactly as specified
    worksheet.addRow([
      "Beneficiary Msisdn",
      "Beneficiary Name", 
      "Voice(Minutes)",
      "Data (MB) (1024MB = 1GB)",
      "Sms(Unit)"
    ]);
    
    const headerRow = worksheet.lastRow!;
    headerRow.eachCell(cell => {
      cell.font = { bold: true };
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };
    });
    
    // Add entries with the specified format and default values
    order.entries.forEach(entry => {
      // Convert GB to MB for the Data column
      const dataMB = Math.round(entry.allocationGB * 1024);
      
      const row = worksheet.addRow([
        entry.number,      // Beneficiary Msisdn
        "",                // Beneficiary Name (empty)
        0,                 // Voice(Minutes) - default 0
        dataMB,            // Data (MB)
        0                  // Sms(Unit) - default 0
      ]);
      
      // Color code based on status
      if (entry.status === "error") {
        row.getCell(1).font = { color: { argb: "FFFF0000" } }; // Red for MSISDN with error
      }
    });
    
    // Add an empty row after the entries
    worksheet.addRow([]);
    
    // Calculate the last row number and add summary row in column F
    const lastRowNum = worksheet.rowCount;
    const totalDataRow = worksheet.getRow(lastRowNum);
    
    // Add number count summary in cell F
    totalDataRow.getCell(6).value = `Total Numbers: ${order.entries.length}`;
    totalDataRow.getCell(6).font = { bold: true };
    
    // Add total data allocation in cell F on the next row
    const totalDataMB = Math.round(order.totalData * 1024);
    const totalGBRow = worksheet.getRow(lastRowNum + 1);
    totalGBRow.getCell(6).value = `Total Data: ${totalDataMB} MB (${order.totalData.toFixed(2)} GB)`;
    totalGBRow.getCell(6).font = { bold: true };
    
    // Auto-size columns
    worksheet.columns.forEach(column => {
      if (column && typeof column.eachCell === 'function') {
        let maxLength = 0;
        column.eachCell({ includeEmpty: true }, cell => {
          const length = cell.value ? cell.value.toString().length : 10;
          if (length > maxLength) {
            maxLength = length;
          }
        });
        column.width = maxLength + 2;
      }
    });
    
    // Set specific widths for standard columns
    if (worksheet.columnCount >= 5) {
      // Ensure Beneficiary Msisdn column has enough width
      worksheet.getColumn(1).width = Math.max(worksheet.getColumn(1).width || 15, 20);
      // Ensure Beneficiary Name column has enough width
      worksheet.getColumn(2).width = Math.max(worksheet.getColumn(2).width || 15, 25);
      // Ensure Data column has enough width for the header
      worksheet.getColumn(4).width = Math.max(worksheet.getColumn(4).width || 15, 30);
    }
    
    // No summary sheet with order metadata - removing this section as requested
    
    // Set PhoneData as the active sheet when opening the file
    // ExcelJS requires all these properties for a WorkbookView
    workbook.views = [
      { 
        x: 0,
        y: 0,
        width: 10000,
        height: 20000,
        firstSheet: 0,
        activeTab: 0,
        visibility: 'visible'
      }
    ];
    
    // Generate and return the buffer (for individual download) or buffer+filename (for bulk)
    const buffer = await workbook.xlsx.writeBuffer();
    const filename = `Order_${order.id}_${order.date}.xlsx`;
    
    return { buffer, filename };
  };
  
  // Download a single order directly and mark it as processed
  const downloadSingleOrder = async (order: Order) => {
    try {
      const { buffer, filename } = await downloadOrder(order);
      
      const blob = new Blob([buffer], {
        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      });
      
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
      
      // Get current date and time for processing timestamp
      const now = new Date();
      const processedDate = now.toISOString().split('T')[0];
      const processedTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      // Update the order status to "processed" after downloading and update timestamp
      const updatedOrder = { 
        ...order, 
        status: "processed" as const,
        timestamp: now.getTime(),
        date: processedDate,
        time: processedTime
      };
      
      // Update the local state
      const updatedOrders = orders.map(o => o.id === order.id ? updatedOrder : o);
      setOrders(updatedOrders);
      
      // Update in database
      await updateOrder(updatedOrder);
      
      // Refresh the order counts to update badges
      refreshOrderCount();
      
    } catch (error) {
      console.error("Error downloading order:", error);
      alert("Failed to download order. Please try again.");
    }
  };
  
  // Merge multiple orders into a single Excel file
  const mergeOrdersToSingleExcel = async (ordersToMerge: Order[]) => {
    try {
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet("PhoneData");
      
      // Add header columns
      worksheet.addRow([
        "Beneficiary Msisdn",
        "Beneficiary Name", 
        "Voice(Minutes)",
        "Data (MB) (1024MB = 1GB)",
        "Sms(Unit)"
      ]);
      
      // Format header row
      const headerRow = worksheet.lastRow!;
      headerRow.eachCell(cell => {
        cell.font = { bold: true };
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFE0E0E0' }
        };
      });
      
      // Accumulate all entries from all orders
      let totalEntries = 0;
      let totalDataMB = 0;
      
      for (const order of ordersToMerge) {
        // Add entries for this order directly without the order info header
        order.entries.forEach(entry => {
          // Convert GB to MB for the Data column
          const dataMB = Math.round(entry.allocationGB * 1024);
          totalDataMB += dataMB;
          
          const row = worksheet.addRow([
            entry.number,      // Beneficiary Msisdn
            "",                // Beneficiary Name (empty)
            0,                 // Voice(Minutes) - default 0
            dataMB,            // Data (MB)
            0                  // Sms(Unit) - default 0
          ]);
          
          // Color code based on status
          if (entry.status === "error") {
            row.getCell(1).font = { color: { argb: "FFFF0000" } }; // Red for MSISDN with error
          }
        });
        
        totalEntries += order.entries.length;
      }
      
      // Add an empty row after all entries
      worksheet.addRow([]);
      
      // Add summary information
      const lastRowNum = worksheet.rowCount;
      const totalDataRow = worksheet.getRow(lastRowNum);
      
      // Add number count summary in cell F
      totalDataRow.getCell(6).value = `Total Numbers: ${totalEntries}`;
      totalDataRow.getCell(6).font = { bold: true };
      
      // Add total data allocation in cell F on the next row
      const totalGBRow = worksheet.getRow(lastRowNum + 1);
      const totalGB = totalDataMB / 1024;
      totalGBRow.getCell(6).value = `Total Data: ${totalDataMB} MB (${totalGB.toFixed(2)} GB)`;
      totalGBRow.getCell(6).font = { bold: true };
      
      // Auto-size columns
      worksheet.columns.forEach(column => {
        if (column && typeof column.eachCell === 'function') {
          let maxLength = 0;
          column.eachCell({ includeEmpty: true }, cell => {
            const length = cell.value ? cell.value.toString().length : 10;
            if (length > maxLength) {
              maxLength = length;
            }
          });
          column.width = maxLength + 2;
        }
      });
      
      // Set specific widths for standard columns
      if (worksheet.columnCount >= 5) {
        // Ensure Beneficiary Msisdn column has enough width
        worksheet.getColumn(1).width = Math.max(worksheet.getColumn(1).width || 15, 20);
        // Ensure Beneficiary Name column has enough width
        worksheet.getColumn(2).width = Math.max(worksheet.getColumn(2).width || 15, 25);
        // Ensure Data column has enough width for the header
        worksheet.getColumn(4).width = Math.max(worksheet.getColumn(4).width || 15, 30);
      }
      
      // No summary sheet with order metadata - removing this section as requested
      
      // Set PhoneData as the active sheet when opening the file
      workbook.views = [
        { 
          x: 0,
          y: 0,
          width: 10000,
          height: 20000,
          firstSheet: 0,
          activeTab: 0,
          visibility: 'visible'
        }
      ];
      
      // Generate the workbook buffer
      const buffer = await workbook.xlsx.writeBuffer();
      return buffer;
    } catch (error) {
      console.error("Error merging orders:", error);
      throw error;
    }
  };
  
  // Download selected orders as a merged Excel file or ZIP file
  const downloadSelectedOrders = async () => {
    if (selectedOrderIds.length === 0) {
      alert("Please select at least one order to download.");
      return;
    }
    
    try {
      // Show loading state
      setIsLoading(true);
      
      // If only one order is selected, download directly
      if (selectedOrderIds.length === 1) {
        const order = orders.find(o => o.id === selectedOrderIds[0]);
        if (order) {
          await downloadSingleOrder(order);
          setIsLoading(false);
        }
        return;
      }
      
      // Get all selected orders
      const selectedOrders = orders.filter(order => selectedOrderIds.includes(order.id));
      
      // If selectAll is true or all filtered orders are selected, merge into one file
      const allFilteredOrdersSelected = 
        selectAll || 
        (selectedOrderIds.length === filteredOrders.length && selectedOrderIds.length > 1);
        
      if (allFilteredOrdersSelected) {
        // Merge all selected orders into a single Excel file
        const mergedBuffer = await mergeOrdersToSingleExcel(selectedOrders);
        
        // Create download link for merged file
        const blob = new Blob([mergedBuffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `Merged_Orders_${new Date().toISOString().split('T')[0]}.xlsx`;
        link.click();
        URL.revokeObjectURL(url);
        
        // Get current date and time for processing timestamp
        const now = new Date();
        const processedDate = now.toISOString().split('T')[0];
        const processedTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        // Mark all selected orders as processed with updated timestamps
        const updatedOrders = orders.map(order => 
          selectedOrderIds.includes(order.id) 
            ? { 
                ...order, 
                status: "processed" as const,
                timestamp: now.getTime(),
                date: processedDate,
                time: processedTime
              } 
            : order
        );
        
        setOrders(updatedOrders);
        
        // Update each order in the database
        const updatePromises = updatedOrders
          .filter(order => selectedOrderIds.includes(order.id))
          .map(order => updateOrder(order));
        
        await Promise.all(updatePromises);
        
        // Refresh the order counts to update badges
        refreshOrderCount();
        
        // Hide loading state
        setIsLoading(false);
        
        alert(`Successfully merged and downloaded ${selectedOrders.length} orders into a single file.`);
      } else {
        // Create a zip file with separate Excel files for each order
        const zip = new JSZip();
        
        // Process each selected order
        const promises = selectedOrders.map(async order => {
          try {
            const { buffer, filename } = await downloadOrder(order);
            zip.file(filename, buffer);
          } catch (error) {
            console.error(`Error processing order ${order.id}:`, error);
          }
        });
        
        await Promise.all(promises);
        
        // Generate zip file
        const zipContent = await zip.generateAsync({ type: 'blob' });
        
        // Create download link
        const url = URL.createObjectURL(zipContent);
        const link = document.createElement('a');
        link.href = url;
        link.download = `Orders_Batch_${new Date().toISOString().split('T')[0]}.zip`;
        link.click();
        URL.revokeObjectURL(url);
        
        // Get current date and time for processing timestamp
        const now = new Date();
        const processedDate = now.toISOString().split('T')[0];
        const processedTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        // Mark all selected orders as processed with updated timestamps
        const updatedOrders = orders.map(order => 
          selectedOrderIds.includes(order.id) 
            ? { 
                ...order, 
                status: "processed" as const,
                timestamp: now.getTime(),
                date: processedDate,
                time: processedTime
              } 
            : order
        );
        
        setOrders(updatedOrders);
        
        // Update each order in the database
        const updatePromises = updatedOrders
          .filter(order => selectedOrderIds.includes(order.id))
          .map(order => updateOrder(order));
        
        await Promise.all(updatePromises);
        
        // Refresh the order counts to update badges
        refreshOrderCount();
        
        // Hide loading state
        setIsLoading(false);
        
        alert(`Successfully downloaded ${selectedOrders.length} orders as separate files.`);
      }
    } catch (error) {
      console.error("Error downloading selected orders:", error);
      alert("Failed to download selected orders. Please try again.");
      setIsLoading(false);
    }
  };

  // Get status badge styling
  const getStatusBadge = (status: Order["status"]) => {
    switch (status) {
      case "pending":
        return { 
          bgColor: "bg-yellow-100", 
          textColor: "text-yellow-800",
          icon: <Clock className="w-3 h-3 sm:w-4 sm:h-4" />
        };
      case "processed":
        return { 
          bgColor: "bg-green-100", 
          textColor: "text-green-800",
          icon: <CheckCircle className="w-3 h-3 sm:w-4 sm:h-4" />
        };
      default:
        return { 
          bgColor: "bg-gray-100", 
          textColor: "text-gray-800",
          icon: <Clock className="w-3 h-3 sm:w-4 sm:h-4" />
        };
    }
  };

  // Effect to update selectAll state when filters or search changes
  useEffect(() => {
    if (filteredOrders.length > 0) {
      const allFilteredSelected = filteredOrders.every(order => order.isSelected);
      setSelectAll(allFilteredSelected);
    } else {
      setSelectAll(false);
    }
  }, [filteredOrders, statusFilter, searchTerm]);
  
  // Listen for order updated events to refresh the list
  useEffect(() => {
    const handleOrderUpdate = async () => {
      try {
        setIsLoading(true);
        // Load all orders, not just pending ones
        const allOrders = await getOrdersOldestFirst();
        setOrders(allOrders);
      } catch (error) {
        console.error("Error refreshing orders:", error);
      } finally {
        setIsLoading(false);
      }
    };
    
    // Set up event listener for order updates
    window.addEventListener(ORDER_UPDATED_EVENT, handleOrderUpdate);
    
    // Clean up the event listener
    return () => {
      window.removeEventListener(ORDER_UPDATED_EVENT, handleOrderUpdate);
    };
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-blue-50">
      <div className="max-w-7xl mx-auto px-2 sm:px-4 py-4 sm:py-8">
        {/* Order Queue Header */}
        <div className="bg-white rounded-xl sm:rounded-2xl shadow-xl border border-gray-200 overflow-hidden mb-4 sm:mb-6">
          <div className="p-3 sm:p-6 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-indigo-50">
            <h2 className="text-lg sm:text-xl font-bold text-gray-900 flex items-center gap-2 sm:gap-3">
              <FileText className="w-5 h-5 sm:w-6 sm:h-6 text-blue-600" />
              <span>Pending Orders Queue</span>
            </h2>
            <p className="text-xs sm:text-sm text-gray-600 mt-1">
              View and download pending orders
            </p>
          </div>
        </div>

        {/* Search and Filters */}
        <div className="bg-white rounded-xl sm:rounded-2xl shadow-md border border-gray-200 p-3 sm:p-4 mb-4 sm:mb-6">
          <div className="flex flex-col sm:flex-row gap-3 sm:items-center">
            {/* Search */}
            <div className="relative flex-1">
              <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <Search className="h-4 w-4 text-gray-400" />
              </div>
              <input
                type="text"
                placeholder="Search orders by user or date..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            
            {/* Status Filter */}
            <div className="flex items-center gap-2">
              <SlidersHorizontal className="h-4 w-4 text-gray-500" />
              <select 
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value as any)}
                className="text-sm border border-gray-300 rounded-md py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">All Pending</option>
                <option value="pending">Pending Only</option>
              </select>
            </div>
            
            {/* Bulk Download Button */}
            {selectedOrderIds.length > 0 && (
              <button
                onClick={downloadSelectedOrders}
                className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white py-2 px-3 sm:px-4 rounded-md text-sm font-medium transition-colors"
              >
                <Archive className="h-4 w-4" />
                <span>Download {selectedOrderIds.length} Selected</span>
              </button>
            )}
          </div>
        </div>

        {/* Orders Table */}
        <div className="bg-white rounded-xl sm:rounded-2xl shadow-xl border border-gray-200 overflow-hidden">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th scope="col" className="px-2 sm:px-4 py-3 text-center">
                    <div 
                      className="cursor-pointer inline-flex justify-center"
                      onClick={handleToggleSelectAll}
                    >
                      {selectAll ? (
                        <CheckSquare className="h-5 w-5 text-blue-600 hover:text-blue-700 transition-colors" />
                      ) : (
                        <Square className="h-5 w-5 text-gray-400 hover:text-gray-700 transition-colors" />
                      )}
                    </div>
                  </th>
                  <th 
                    scope="col" 
                    className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort("date")}
                  >
                    <div className="flex items-center gap-1">
                      <span>Date & Time</span>
                      {sortField === "date" && (
                        <span className="text-blue-500">
                          {sortDirection === "asc" ? " ↑" : " ↓"}
                        </span>
                      )}
                    </div>
                  </th>
                  <th 
                    scope="col" 
                    className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort("userName")}
                  >
                    <div className="flex items-center gap-1">
                      <span>Submitted By</span>
                      {sortField === "userName" && (
                        <span className="text-blue-500">
                          {sortDirection === "asc" ? " ↑" : " ↓"}
                        </span>
                      )}
                    </div>
                  </th>
                  <th 
                    scope="col" 
                    className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort("totalData")}
                  >
                    <div className="flex items-center gap-1">
                      <span>Total Data</span>
                      {sortField === "totalData" && (
                        <span className="text-blue-500">
                          {sortDirection === "asc" ? " ↑" : " ↓"}
                        </span>
                      )}
                    </div>
                  </th>
                  <th 
                    scope="col" 
                    className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort("totalCount")}
                  >
                    <div className="flex items-center gap-1">
                      <span>Total Count</span>
                      {sortField === "totalCount" && (
                        <span className="text-blue-500">
                          {sortDirection === "asc" ? " ↑" : " ↓"}
                        </span>
                      )}
                    </div>
                  </th>
                  <th scope="col" className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">
                    Status
                  </th>
                  <th scope="col" className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {isLoading ? (
                  <tr>
                    <td colSpan={6} className="px-4 py-12 text-center">
                      <div className="flex flex-col items-center justify-center">
                        <Loader className="h-8 w-8 text-blue-500 animate-spin mb-3" />
                        <p className="text-gray-500">Loading orders...</p>
                      </div>
                    </td>
                  </tr>
                ) : filteredOrders.length === 0 ? (
                  <tr>
                    <td colSpan={6} className="px-4 py-12 text-center">
                      <div className="flex flex-col items-center justify-center">
                        <FileText className="h-8 w-8 text-gray-400 mb-3" />
                        <p className="text-gray-500">No orders found</p>
                        {searchTerm || statusFilter !== "all" ? (
                          <p className="text-gray-400 text-sm mt-1">Try adjusting your filters</p>
                        ) : null}
                      </div>
                    </td>
                  </tr>
                ) : (
                  filteredOrders.map((order) => {
                    const statusStyle = getStatusBadge(order.status);
                    
                    return (
                      <tr key={order.id} className={`hover:bg-gray-50 transition-colors ${order.isSelected ? 'bg-blue-50' : ''}`}>
                        <td className="px-2 sm:px-4 py-4 text-center">
                          <div 
                            className="cursor-pointer inline-flex justify-center"
                            onClick={() => toggleOrderSelection(order.id)}
                          >
                            {order.isSelected ? (
                              <CheckSquare className="h-5 w-5 text-blue-600 hover:text-blue-700 transition-colors" />
                            ) : (
                              <Square className="h-5 w-5 text-gray-400 hover:text-gray-700 transition-colors" />
                            )}
                          </div>
                        </td>
                        <td className="px-4 py-4 whitespace-nowrap">
                          <div className="flex flex-col">
                            <div className="text-sm font-medium text-gray-900">
                              {order.date}
                            </div>
                            <div className="text-xs text-gray-500">
                              {order.time}
                            </div>
                          </div>
                        </td>
                        <td className="px-4 py-4 whitespace-nowrap">
                          <div className="flex items-center">
                            <div className="h-8 w-8 rounded-full bg-blue-100 flex items-center justify-center text-blue-600">
                              <User className="h-4 w-4" />
                            </div>
                            <div className="ml-3">
                              <div className="text-sm font-medium text-gray-900">
                                {order.userName}
                              </div>
                              <div className="text-xs text-gray-500">
                                {order.userEmail}
                              </div>
                            </div>
                          </div>
                        </td>
                        <td className="px-4 py-4 whitespace-nowrap">
                          <div className="flex items-center">
                            <div className="mr-2">
                              <Database className="h-4 w-4 text-purple-600" />
                            </div>
                            <div>
                              <div className="text-sm font-bold text-gray-900">
                                {order.totalData} GB
                              </div>
                              <div className="text-xs text-gray-500">
                                {(order.totalData * 1024).toLocaleString()} MB
                              </div>
                            </div>
                          </div>
                        </td>
                        <td className="px-4 py-4 whitespace-nowrap">
                          <span className="text-sm font-medium text-gray-900">
                            {order.totalCount} numbers
                          </span>
                        </td>
                        <td className="px-4 py-4 whitespace-nowrap">
                          <div className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${statusStyle.bgColor} ${statusStyle.textColor} gap-1.5`}>
                            {statusStyle.icon}
                            <span className="capitalize">{order.status}</span>
                          </div>
                        </td>
                        <td className="px-4 py-4 whitespace-nowrap text-sm font-medium">
                          <button
                            onClick={() => downloadSingleOrder(order)}
                            className="inline-flex items-center p-1.5 border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 transition"
                            title="Download order"
                          >
                            <Download className="h-4 w-4 text-gray-600" />
                          </button>
                        </td>
                      </tr>
                    );
                  })
                )}
              </tbody>
            </table>
          </div>
        </div>

        {/* Stats Summary */}
        {!isLoading && filteredOrders.length > 0 && (
          <div className="mt-4 sm:mt-6 flex justify-between items-center">
            <div className="text-xs text-gray-500">
              {selectedOrderIds.length > 0 ? (
                <span className="text-blue-600 font-medium">
                  {selectedOrderIds.length} {selectedOrderIds.length === 1 ? 'order' : 'orders'} selected
                </span>
              ) : null}
            </div>
            <div className="text-right text-xs text-gray-500">
              Showing {filteredOrders.length} of {orders.length} orders
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
